name: Generate GitHub Actions Versions JSON

on:
  schedule:
    - cron: "0 0 * * *" # ÊØèÂ§© UTC Êó∂Èó¥ 00:00 ËøêË°å
  workflow_dispatch: # ÂÖÅËÆ∏ÊâãÂä®Ëß¶Âèë

env:
  # ‰øùÂ≠òÂú∞ÂùÄ
  JSON_FILE_PATH: ${{ github.workspace }}/actions-versions.json

  # Êï∞ÊçÆ‰∏≠ÂøÉÊñá‰ª∂
  DATA_CENTER_FILE: ${{ github.workspace }}/data.json

  # Âú®Êï∞ÊçÆ‰∏≠ÂøÉÁöÑÊ†áËØÜ
  DATA_CENTER_NAME: actions-versions

  # ÊçïËé∑
  GITHUB_REPOS: '["actions/checkout", "actions/setup-node", "actions/setup-python", "actions/setup-dotnet", "actions/setup-java", "actions/cache", "actions/upload-artifact", "actions/download-artifact", "codecov/codecov-action", "dorny/test-reporter", "super-linter/super-linter", "sonarsource/sonarqube-scan-action", "aquasecurity/trivy-action", "actions/deploy-pages", "JamesIves/github-pages-deploy-action", "docker/login-action", "docker/setup-buildx-action", "docker/build-push-action", "google-github-actions/deploy-appengine", "azure/webapps-deploy", "aws-actions/configure-aws-credentials", "aws-actions/aws-cloudformation-github-deploy", "appleboy/ssh-action", "slackapi/slack-github-action", "actions/github-script", "actions/labeler", "actions/stale", "actions/create-release", "softprops/action-gh-release", "dephraiim/translate-readme"]'

  # ÊçïËé∑‰∏Ä‰∏™‰ªìÂ∫ìÊâÄÈúÄËØ∑Ê±ÇÊï∞
  REQUESTS_PER_REPO: 2

  # Êú™È™åËØÅË∫´‰ªΩÁöÑËØ∑Ê±ÇÔºåÊúÄÂ§ßÂÄº
  UNAUTHENTICATED_REQUESTS_MAX: 60

  # ÊúÄÂ§ß‰Ωú‰∏ö
  MAX_JOBS: 20

  # ËØ•ActionÊúÄÂ§ßAPIËØ∑Ê±ÇÊ¨°Êï∞„Äê‰∏Ä‰∏™Â≠òÂÇ®Â∫ì‰∏≠ÊâÄÊúâÊìç‰ΩúÂú®‰∏ÄÂ∞èÊó∂ÂÜÖÊúÄÂ§öÂèØ‰ª•ÊâßË°å 1,000 Êù°ÂØπ GitHub API ÁöÑËØ∑Ê±Ç„Äë
  MAX_API_REQUESTS: 500

  # ISSUE_ID
  ISSUE_ID: 1

jobs:
  # Ê†πÊçÆGITHUB_REPOSËøõË°åÂàÜÂâ≤
  split:
    runs-on: ubuntu-latest
    outputs:
      GITHUB_REPOS_LIST: ${{ steps.split.outputs.GITHUB_REPOS_LIST }}
    steps:
      # ÊØèÂ∞èÊó∂ÂèØÊçïËé∑ÁöÑ‰ªìÂ∫ìÊï∞Èáè = MAX_API_REQUESTS / REQUESTS_PER_REPO
      # Âà§Êñ≠ÊòØÂê¶Ë∂ÖËøáÊúÄÂ§ßÂÄºÔºüÁªô‰ªìÂ∫ìÊâÄÊúâËÄÖÊèêÈÜí
      - name: Check if the number of repositories exceeds the maximum
        uses: actions/github-script@v6
        id: split
        env:
          OWNER: ${{ github.repository_owner }}
          REPO: ${{ github.repository }}
        with:
          script: |
            // ÊâÄÊúâËÄÖ
            const OWNER = process.env.OWNER;
            const REPO = process.env.REPO.replace(`${OWNER}/`, "");
            const MAX_API_REQUESTS = parseInt(process.env.MAX_API_REQUESTS);
            const REQUESTS_PER_REPO = parseInt(process.env.REQUESTS_PER_REPO);
            // ËÆ°ÁÆóÊúÄÂ§ß‰ªìÂ∫ìÊï∞Èáè[Âêë‰∏ãÂèñÊï¥]
            const MAX_GITHUB_REPOS = Math.floor(MAX_API_REQUESTS / REQUESTS_PER_REPO);
            const GITHUB_REPOS = JSON.parse(process.env.GITHUB_REPOS);

            if (GITHUB_REPOS.length > MAX_GITHUB_REPOS) {
              // ÂêëISSUE #1 ÂõûÂ§ç
              await github.rest.issues.createComment({
                owner: OWNER,
                repo: REPO,
                issue_number: process.env.ISSUE_ID,
                body: `
                  ### ‚ö†Ô∏è Warning: Too many repositories being monitored (${GITHUB_REPOS.length} > ${MAX_GITHUB_REPOS}).
                `,
              })
             
              throw new Error(`Too many repositories being monitored (${GITHUB_REPOS.length} > ${MAX_GITHUB_REPOS}).`);
            }

            const MAX_JOBS = parseInt(process.env.MAX_JOBS);
            const UNAUTHENTICATED_REQUESTS_MAX = parseInt(process.env.UNAUTHENTICATED_REQUESTS_MAX);

            // ÊØè‰∏™JOBÊúÄÂ§öÁõëÂê¨ÁöÑ‰ªìÂ∫ìÊï∞Èáè
            const JOB_MAX_GITHUB_REPOS = Math.floor(UNAUTHENTICATED_REQUESTS_MAX / REQUESTS_PER_REPO);

            // Ëé∑ÂèñÈúÄË¶ÅÁöÑÂ§öÂ∞ë‰∏™JOB
            const NEED_JOBS = Math.ceil(GITHUB_REPOS.length / JOB_MAX_GITHUB_REPOS);

            if(NEED_JOBS > MAX_JOBS){
              await github.rest.issues.createComment({
                owner: OWNER,
                repo: REPO,
                issue_number: process.env.ISSUE_ID,
                body: `
                  ### ‚ö†Ô∏è Warning: Too many jobs (${GITHUB_REPOS.length} > (${NEED_JOBS} > ${MAX_JOBS}).
                `,
              })

              throw new Error(`Too many jobs (${GITHUB_REPOS.length} > (${NEED_JOBS} > ${MAX_JOBS}).`);
            }

            // ÊãÜGITHUB_REPOS
            const GITHUB_REPOS_LIST = []
            for(let i = 0; i < NEED_JOBS; i++){
              // Ëé∑ÂèñÊØè‰∏™JOBÁöÑGITHUB_REPOS
              GITHUB_REPOS_LIST.push({
                index: i,
                repos: GITHUB_REPOS.slice(i * JOB_MAX_GITHUB_REPOS, (i + 1) * JOB_MAX_GITHUB_REPOS)
              })
            }

            console.log(GITHUB_REPOS_LIST)
            core.setOutput('GITHUB_REPOS_LIST', JSON.stringify(GITHUB_REPOS_LIST))


  generate:
    needs: [split]
    strategy:
      matrix:
        job_config: ${{ fromJSON(needs.split.outputs.GITHUB_REPOS_LIST) }}
    runs-on: ubuntu-latest
    env:
      GITHUB_REPOS: ${{ toJson(matrix.job_config.repos) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Install dependencies
        run: npm install axios

      - name: Run script to generate JSON
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require("fs");
            const axios = require("axios");

            const GITHUB_REPOS = JSON.parse(process.env.GITHUB_REPOS);

            const headers = {
                Accept: "application/vnd.github.v3+json",
            };

            // ËØªÂèñJSONÊñá‰ª∂
            const readJson = (path) => {
              try {
                  return JSON.parse(fs.readFileSync(path, "utf8"));
              } catch (error) {
                  return null;
              }
            }

            const updateActionDataList = (actionDataList, actionData) => {
              try {
                let actionRepo = actionData.repo;
                let index = actionDataList.findIndex((item) => item.repo === actionRepo);
                if(index === -1) {
                  actionDataList.push(actionData);
                  return actionDataList;
                }
                actionDataList[index] = actionData;
                return actionDataList;
              } catch (error) {
                console.log("Error updating actionDataList", error.message);
                return actionDataList;
              }
            }


            const fetchApi = async (url) => {
              try {
                  const response = await axios.get(url, { headers });
                  const rateLimit = response.headers["x-ratelimit-limit"];
                  const rateLimitRemaining = response.headers["x-ratelimit-remaining"];
                  const rateLimitReset = response.headers["x-ratelimit-reset"];

                  console.log(`üîÑ Rate limit remaining: ${rateLimitRemaining}/${rateLimit}`);

                  if(rateLimitRemaining === "0") {
                    const resetTime = new Date(rateLimitReset * 1000).toLocaleTimeString();
                    const waitTime = rateLimitReset * 1000 - Date.now();
                    console.log(`‚è≥ Rate limit exceeded, waiting until ${resetTime}...`);
                    await new Promise((resolve) => setTimeout(resolve, waitTime));

                    return await fetchApi(url);
                  }

                  return response.data;
              } catch (error) {
                  if (error.response && error.response.status === 403) {
                      const rateLimitReset = error.response.headers["x-ratelimit-reset"];
                      const resetTime = new Date(rateLimitReset * 1000).toLocaleTimeString();
                      const waitTime = rateLimitReset * 1000 - Date.now();

                      console.log(`‚è≥ Rate limit exceeded, waiting until ${resetTime}...`);
                      await new Promise((resolve) => setTimeout(resolve, waitTime));

                      return await fetchApi(url);
                  }

                  console.error(`‚ùå Error fetching ${url}:`, error.message);
                  throw error;
              }
            };

            async function fetchLatestTag(git_repo) {
                try {
                    const url = `https://api.github.com/repos/${git_repo}`;
                    console.log(`üì° Fetching data from ${url}...`);
                    const repoData = await fetchApi(url);

                    const description = repoData.description;
                    const archived = repoData.archived;
                    const docsUrl = repoData.html_url;

                    // ËØ∑Ê±Çreleases
                    const releasesUrl = repoData.releases_url.replace("{/id}", "");
                    const releasesResponse = await fetchApi(releasesUrl);

                    // Ê£ÄÊü•ÊòØÂê¶Êúâreleases
                    if (releasesResponse.length === 0) {
                        console.log(`‚ö†Ô∏è No releases found for ${git_repo}`);
                        return {
                            latest: "N/A",
                            major: "N/A",
                            status: archived ? "deprecated" : "active",
                            description: description,
                            releaseDate: "N/A",
                            changelog: "N/A",
                            docsUrl: docsUrl,
                        };
                    }

                    // Ëé∑ÂèñÊúÄÊñ∞ÁöÑrelease‰ø°ÊÅØ
                    const latestRelease = releasesResponse[0];
                    const latestTag = latestRelease.tag_name;
                    const releaseDate = latestRelease.published_at;
                    const changelog = latestRelease.body || "No changelog provided";

                    console.log(`‚úÖ Latest tag for ${git_repo}: ${latestTag}`);

                    return {
                        latest: latestTag,
                        major: parseTag(latestTag),
                        status: archived ? "deprecated" : "active",
                        description: description,
                        releaseDate: releaseDate,
                        changelog: changelog,
                        docsUrl: docsUrl,
                    };
                } catch (error) {
                    console.error(`‚ùå Error fetching ${git_repo}:`, error.message);
                    return {
                        latest: "Error",
                        major: "Error",
                        status: "Error",
                        description: "Error",
                        releaseDate: "Error",
                        changelog: "Error",
                        docsUrl: "Error",
                    };
                }
            }

            function parseTag(tag) {
                return tag.replace(/^v/, "").split(".")[0];
            }

            (async () => {
                try {
                    const repos = GITHUB_REPOS;
                    const jsonData = readJson(process.env.JSON_FILE_PATH)
                    const data = {
                        actions: jsonData.actions,
                        updated: new Date().toISOString(),
                    };
                    

                    for (const repo of repos) {
                        console.log(`üîç Processing repository: ${repo}`);
                        const result = await fetchLatestTag(repo);
                        let actionData = {
                            repo,
                            latest: result.latest,
                            major: result.major,
                            description: result.description,
                            status: result.status,
                            releaseDate: result.releaseDate,
                            changelog: result.changelog,
                            docsUrl: result.docsUrl,
                        }

                        data.actions = updateActionDataList(data.actions, actionData)
                    }

                    fs.writeFileSync(process.env.JSON_FILE_PATH, JSON.stringify(data, null, 2));
                    console.log(`üìÑ JSON file generated: ${process.env.JSON_FILE_PATH}`);
                } catch (error) {
                    console.error("‚ùå Error:", error.message);
                    process.exit(1);
                }
            })();
      
      - name: Update JSON file
        uses: actions/github-script@v6
        with:
          script: |
            const {buildData, processDataUpdate} = require('.github/utils/json.js');

            const json_path = process.env.JSON_FILE_PATH.replace(`${process.env.GITHUB_WORKSPACE}/`, '');

            const data = buildData({
              name: process.env.DATA_CENTER_NAME,
              description: 'Github Actions Versions',
              description_zh: 'GitHub Actions Runner Êìç‰ΩúÁ≥ªÁªüÁâàÊú¨',
              path: [json_path]
            });

            processDataUpdate(process.env.DATA_CENTER_FILE, data)
            console.log(`JSON Êñá‰ª∂Â∑≤Êõ¥Êñ∞Ôºö${process.env.DATA_CENTER_FILE}`);

      - name: Commit and push changes
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add ${{ env.JSON_FILE_PATH }}
          git commit -m "Auto-generated JSON file [skip ci]"
          git add ${{ env.DATA_CENTER_FILE }}
          git commit -m "Update data center file [skip ci]"
          git push